{
  "comments": [
    {
      "key": {
        "uuid": "fa82b9bf_f26a38ed",
        "filename": "opendaylight/commons/opendaylight/pom.xml",
        "patchSetId": 2
      },
      "lineNbr": 23,
      "author": {
        "id": 1840
      },
      "writtenOn": "2014-06-23T13:34:56Z",
      "side": 1,
      "message": "Likely this change was automatic with the pom sorter, but I think we keep seeing changes like this because the arphandler.version is defined twice. :) \n\nCan we clean up this pom here and remove the duplicate version? Or we should undo this change and make another commit that does that.",
      "revId": "55f25ec1879307a34367eebc2946617014d6e2d1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fa82b9bf_38b96115",
        "filename": "opendaylight/commons/opendaylight/pom.xml",
        "patchSetId": 2
      },
      "lineNbr": 23,
      "author": {
        "id": 9
      },
      "writtenOn": "2014-06-23T20:30:47Z",
      "side": 1,
      "message": "Yes, this is the auto-behavior... removing the dup would be goodness.",
      "parentUuid": "fa82b9bf_f26a38ed",
      "revId": "55f25ec1879307a34367eebc2946617014d6e2d1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fa82b9bf_75129258",
        "filename": "opendaylight/md-sal/sal-binding-it/src/test/java/org/opendaylight/controller/test/sal/util/it/AbstractLazyNotificationTransformerTest.java",
        "patchSetId": 2
      },
      "lineNbr": 58,
      "author": {
        "id": 1840
      },
      "writtenOn": "2014-06-23T13:34:56Z",
      "side": 1,
      "message": "Relying on a sleep to get around timing issues can be problematic. It would be better to use a CountDownLatch and get explicit notification when you are ready to continue. This will lead to a faster test as well.",
      "revId": "55f25ec1879307a34367eebc2946617014d6e2d1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fa82b9bf_d83955a5",
        "filename": "opendaylight/md-sal/sal-binding-it/src/test/java/org/opendaylight/controller/test/sal/util/it/AbstractLazyNotificationTransformerTest.java",
        "patchSetId": 2
      },
      "lineNbr": 58,
      "author": {
        "id": 9
      },
      "writtenOn": "2014-06-23T20:30:47Z",
      "side": 1,
      "message": "Tell me more about CountDownLatch... I just copied this from the existing MD-SAL integration tests.  Happy to do better.",
      "parentUuid": "fa82b9bf_75129258",
      "revId": "55f25ec1879307a34367eebc2946617014d6e2d1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fa82b9bf_b8e011fb",
        "filename": "opendaylight/md-sal/sal-binding-it/src/test/java/org/opendaylight/controller/test/sal/util/it/AbstractLazyNotificationTransformerTest.java",
        "patchSetId": 2
      },
      "lineNbr": 58,
      "author": {
        "id": 1840
      },
      "writtenOn": "2014-06-23T21:07:40Z",
      "side": 1,
      "message": "CountDownLatch is a java construct located here:\n\nhttp://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html\n\nBasically:\n\nfinal CountDownLatch cdl \u003d new CountDownLatch( 1 );\n\nnew Thread( new Runnable(){ public void run(){ cdl.countDown(); } } ).start();\n\ncdl.await(); //this call will block until the count down latch reaches 0. In our case as soon as the thread above executes the call \"countDown\". This is a great way for code to block until you reach certain logical points in the process.",
      "parentUuid": "fa82b9bf_d83955a5",
      "revId": "55f25ec1879307a34367eebc2946617014d6e2d1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fa82b9bf_95071618",
        "filename": "opendaylight/md-sal/sal-binding-util/src/main/java/org/opendaylight/controller/md/sal/binding/util/AbstractLazyNotificationTransformer.java",
        "patchSetId": 2
      },
      "lineNbr": 73,
      "author": {
        "id": 1840
      },
      "writtenOn": "2014-06-23T13:34:56Z",
      "side": 1,
      "message": "Since there are missing comments on the interfaces I am not following the full picture. But is it possible that there are two types of notifications we are listening for? If so we will loose registrations with this \"newing\" of a map here.",
      "revId": "55f25ec1879307a34367eebc2946617014d6e2d1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fa82b9bf_f83e998b",
        "filename": "opendaylight/md-sal/sal-binding-util/src/main/java/org/opendaylight/controller/md/sal/binding/util/AbstractLazyNotificationTransformer.java",
        "patchSetId": 2
      },
      "lineNbr": 73,
      "author": {
        "id": 9
      },
      "writtenOn": "2014-06-23T20:30:47Z",
      "side": 1,
      "message": "There is an implicit expectation here that we are doing the listener registrations *once* (thus the check to make sure we don\u0027t have any listener registrations in \n\nif ((getListenerRegistrations() \u003d\u003d null || getListenerRegistrations().isEmpty())\n\nSo... basically, if we haven\u0027t registered listeners, we register all of them.  If we have, we don\u0027t reregister.",
      "parentUuid": "fa82b9bf_95071618",
      "revId": "55f25ec1879307a34367eebc2946617014d6e2d1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fa82b9bf_720b882a",
        "filename": "opendaylight/md-sal/sal-binding-util/src/main/java/org/opendaylight/controller/md/sal/binding/util/AbstractLazyNotificationTransformer.java",
        "patchSetId": 2
      },
      "lineNbr": 123,
      "author": {
        "id": 1840
      },
      "writtenOn": "2014-06-23T13:34:56Z",
      "side": 1,
      "message": "Have you thought about concurrency concerns here? I imagine that close() is likely called from a separate thread then the code which sets the listeners etc. I want to ensure we have paid attention to and thought about the concurrency cases.",
      "revId": "55f25ec1879307a34367eebc2946617014d6e2d1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fa82b9bf_983f4d87",
        "filename": "opendaylight/md-sal/sal-binding-util/src/main/java/org/opendaylight/controller/md/sal/binding/util/AbstractLazyNotificationTransformer.java",
        "patchSetId": 2
      },
      "lineNbr": 123,
      "author": {
        "id": 9
      },
      "writtenOn": "2014-06-23T20:30:47Z",
      "side": 1,
      "message": "Good catch... do you think synchronizing the method would be appropriate?",
      "parentUuid": "fa82b9bf_720b882a",
      "revId": "55f25ec1879307a34367eebc2946617014d6e2d1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fa82b9bf_78e60917",
        "filename": "opendaylight/md-sal/sal-binding-util/src/main/java/org/opendaylight/controller/md/sal/binding/util/AbstractLazyNotificationTransformer.java",
        "patchSetId": 2
      },
      "lineNbr": 123,
      "author": {
        "id": 1840
      },
      "writtenOn": "2014-06-23T21:07:40Z",
      "side": 1,
      "message": "That looks to be the safest thing here. Though personally I am not a fan of synchronizing the methods but instead putting an implicit synchronize block around an object. I do this because when you lock on \"This\" you run the risk (how ever remote) that someone else outside of your class could lock on you. On the otherhand, if you lock on an internal object, you are guaranteed that no one else will lock on you.\n\nUltimately you want to do what is the most performant, whether you synchronize on an object or use volatile. Remember you need to synchronize on writes AND reads if the variable can be accessed by multiple threads - the reason you synchronize on the read is you have to ensure that the values are visible to the thread reading them.\n\nI actually am going to post some of these details on the mailing lists tomorrow...\n\nSo in short, yes, I think synchronzing on close is OK(but you have to synchronze on the writes and reads as well), but you may want to consider a more targeted synchronizing to ensure that reading remains performant.",
      "parentUuid": "fa82b9bf_983f4d87",
      "revId": "55f25ec1879307a34367eebc2946617014d6e2d1",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    }
  ]
}