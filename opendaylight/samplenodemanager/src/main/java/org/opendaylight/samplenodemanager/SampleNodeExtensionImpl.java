package org.opendaylight.samplenodemanager;

import org.opendaylight.yang.gen.v1.urn.opendaylight.samplenodeextension.rev140402.SamplenodeextensionService;
import org.opendaylight.yang.gen.v1.urn.opendaylight.samplenodeextension.rev140402.SampleTestNodeBuilder;
import org.opendaylight.yang.gen.v1.urn.opendaylight.samplenodeextension.rev140402.SampleTestNode;
import org.opendaylight.yang.gen.v1.urn.opendaylight.samplenodeextension.rev140402.sample.node.Vlan;
import org.opendaylight.yang.gen.v1.urn.opendaylight.samplenodeextension.rev140402.CreateNodeCommandInput;
import org.opendaylight.yang.gen.v1.urn.opendaylight.samplenodeextension.rev140402.CreateNodeCommandOutput;
import org.opendaylight.yang.gen.v1.urn.opendaylight.samplenodeextension.rev140402.CreateNodeCommandOutputBuilder;
import org.opendaylight.yangtools.yang.common.RpcResult;
import org.opendaylight.yangtools.yang.common.RpcError;
import org.opendaylight.controller.sal.common.util.Futures;
import org.opendaylight.controller.sal.common.util.Rpcs;
import java.util.concurrent.Future;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.Collections;
import java.util.List;
import org.opendaylight.controller.sal.binding.api.NotificationProviderService;
import org.opendaylight.yangtools.yang.binding.InstanceIdentifier;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.nodes.Node;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.nodes.NodeBuilder;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.nodes.NodeKey;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.Nodes;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.NodeId;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.NodesBuilder;
import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.controller.md.sal.common.api.TransactionStatus;
import org.opendaylight.controller.sal.binding.api.data.DataModificationTransaction;

import org.opendaylight.controller.sal.binding.api.data.DataProviderService;


public class SampleNodeExtensionImpl implements SamplenodeextensionService {

    private static final Logger LOG = LoggerFactory.getLogger(SampleNodeExtensionImpl.class);
    private NotificationProviderService notificationProvider;
    private final static InstanceIdentifier<Nodes> ROOT_NODES_PATH =
                                                InstanceIdentifier.builder(Nodes.class).build();
    private DataProviderService dataBrokerService;
    public SampleNodeExtensionImpl() {
    }
    public void setDataProviderService(DataProviderService dps)
    {
         this.dataBrokerService = dps;
    }
    private static int nodeId = 1;
    @Override
    public Future<RpcResult<CreateNodeCommandOutput>> createNodeCommand(CreateNodeCommandInput input) {


        LOG.info("SampleNodeExtensionImpl::createNodeCommand.");
        String manuf= input.getManufacturer();
        List<Vlan> vlanList = input.getVlan();

        // create a new node

        // get data object if it currently exists
        DataObject dObj = dataBrokerService.readConfigurationData(createPath(manuf));
        if (dObj == null) {
            //builds up the Opendaylight-Inventory:Nodes:Node identifier using those autogenerated classes
            NodeId nodeId = new NodeId( manuf );
            NodeKey nodeKey = new NodeKey(nodeId);

            SampleTestNodeBuilder etnb = new SampleTestNodeBuilder();
            etnb.setManufacturer(manuf);
            etnb.setVlan(vlanList);
            SampleTestNode etn = etnb.build();

            Node node = new NodeBuilder()
                                    .setId(nodeId)
                                    .setKey(nodeKey)
                                    .addAugmentation( SampleTestNode.class, etn )
                                    .build();

            Nodes nodes = new NodesBuilder().setNode(
                    Collections.singletonList(node)).build();

            DataModificationTransaction txn = dataBrokerService.beginTransaction();
            //Here we are putting a basic shell of a node in both data stores. In reality you will
            //want to only put config data in the config path, and operational data in the operational
            //path.
            txn.putConfigurationData(ROOT_NODES_PATH, nodes);
            txn.putOperationalData(ROOT_NODES_PATH, nodes);

            try {
                Future<RpcResult<TransactionStatus>> commit = txn.commit();
                RpcResult<TransactionStatus> rpcResult = commit.get();
                TransactionStatus result = rpcResult.getResult();

                if( result.equals( TransactionStatus.FAILED ) ){
                    CreateNodeCommandOutputBuilder cmdOut = new CreateNodeCommandOutputBuilder();
                    cmdOut.setResponse("failure");
                    RpcResult<CreateNodeCommandOutput> res = Rpcs.<CreateNodeCommandOutput> getRpcResult(true,cmdOut.build(),Collections.<RpcError> emptySet());
                    return Futures.immediateFuture(res);
                }

                // TO-DO: Mount additional data????
            } catch (Exception e) {
                if( LOG.isErrorEnabled() )
                {
                    LOG.error( "Caught exception while trying to commit "
                            + "update to IP Device discovery.", e );
                }
                CreateNodeCommandOutputBuilder cmdOut = new CreateNodeCommandOutputBuilder();
                cmdOut.setResponse("failure");
                RpcResult<CreateNodeCommandOutput> res = Rpcs.<CreateNodeCommandOutput> getRpcResult(true,cmdOut.build(),Collections.<RpcError> emptySet());
                return Futures.immediateFuture(res);
            }
        }

        CreateNodeCommandOutputBuilder cmdOut = new CreateNodeCommandOutputBuilder();
        cmdOut.setResponse("success");
        RpcResult<CreateNodeCommandOutput> res = Rpcs.<CreateNodeCommandOutput> getRpcResult(true,cmdOut.build(),Collections.<RpcError> emptySet());
        return Futures.immediateFuture(res);
    }

    private InstanceIdentifier<Node> createPath(String nodeIdStr) {
        return InstanceIdentifier.<Nodes>builder(Nodes.class)
                .<Node, NodeKey>child(Node.class, new NodeKey(new NodeId( nodeIdStr ))).toInstance();
    }

    void setNotificationProvider(NotificationProviderService nps) {
        notificationProvider = nps;
    }


}
