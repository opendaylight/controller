
options {
  STATIC = false;
}

PARSER_BEGIN(FiqlParser)
package org.opendaylight.controller.northbound.commons.query;

import java.util.regex.*;

public class FiqlParser {
  private Class type;

  public static Expression parse(String query, Class cls) throws ParseException {
    FiqlParser parser = new FiqlParser(new java.io.StringReader(query));
    parser.type = cls;
    return parser.START();
  }

  public static void main(String[] args) throws Exception {
    FiqlParser parser = new FiqlParser(new java.io.StringReader(args[0]));
    Expression exp = parser.START();
    System.out.println(exp);
    final String keyToMatch = "foo";
    final String valueToMatch = "barrrrrr";

    boolean result = exp.accept(new Visitor() {
      public boolean visit(LogicalExpression le) {
        System.out.println("=== LE " + le.getOperator() +
                "|" + le.getFirst() + "|" + le.getSecond());
        return (le.getOperator() == LogicalExpression.OP.AND) ?
            le.getFirst().accept(this) && le.getSecond().accept(this) :
            le.getFirst().accept(this) || le.getSecond().accept(this);
      }

      public boolean visit(CompareExpression ce) {
        System.out.println("=== CE " + ce.getOperator() +
                "|" + ce.getSelector() + "|" + ce.getArgument());
         if (ce.getOperator() != CompareExpression.OP.EQ) {
            return true;
         }
         if (keyToMatch.equals(ce.getSelector())) {
            return Pattern.matches(ce.getArgument(), valueToMatch);
         }
         return false;
      }
    });
    System.out.println("RESULT: " + result);
  }

}

PARSER_END(FiqlParser)

/* whitespace */
SKIP :
{
  " " | "\t"
}

TOKEN : {
  <#ALPHA  : ( ["a"-"z", "A"-"Z", "0"-"9"] )+ >
}

TOKEN : {
  <NUM     : ("+"|"-")?(["0"-"9"])+"."(["0"-"9"])* >
  |
  <LPAREN  : "(" >
  |
  <RPAREN  : ")" >
}

/* comparision ops */
TOKEN : {
  <RE      : ("=") >
  |
  <EQ      : ("==" | "=eq=") >
  |
  <NE      : ("!=" | "=ne=") >
  |
  <LT      : ("=lt=" | "<") >
  |
  <LE      : ("=le=" | "<=") >
  |
  <GT      : ("=gt=" | ">") >
  |
  <GE      : ("=ge=" | ">=") >
}

/* ops */
TOKEN : {
  <AND     : (";" | "and") >
  |
  <OR      : ("," | "or") >
}

/* strings */
TOKEN : {
  <STRING : ( ~["\"", "'", "(", ")", ";", ",", "=", "<", ">", "!", "~", " "] )+ >
  |
  <DQ_STRING : ( "\"" ( ~["\""] )* "\"" ) >
  |
  <SQ_STRING : ( "'" ( ~["'"] )* "'" ) >
}

/* Root production */
Expression START() :
{
  Expression e;
}
{
  e = EXPR()
  <EOF>
  {
    return e;
  }
}

Expression EXPR():
{
  ExpressionBuilder builder = new ExpressionBuilder();
  Expression t;
}
{
  t = TERM() { builder.withTerm(t); }
  (
    (<AND> t = TERM()) { builder.withAnd().withTerm(t); }
    |
    (<OR> t = TERM() ) { builder.withOr().withTerm(t); }
  )*
  {
    return builder.build();
  }
}

Expression TERM() :
{
  Token selector, arg;
  Expression exp;
  CompareExpression.OP op;
}
{
  selector = <STRING>
  (
    ( <EQ>  {op=CompareExpression.OP.EQ;} |
      <RE>  {op=CompareExpression.OP.RE;} |
      <NE>  {op=CompareExpression.OP.NE;} |
      <LT>  {op=CompareExpression.OP.LT;} |
      <LE>  {op=CompareExpression.OP.LE;} |
      <GT>  {op=CompareExpression.OP.GT;} |
      <GE>  {op=CompareExpression.OP.GE;}
    )
    ( arg = <STRING> | arg = <DQ_STRING> | arg = <SQ_STRING> | arg = <NUM>)
  ) { return new CompareExpression(op, selector.image, arg.image); }
  |
  (
    <LPAREN> exp = EXPR() <RPAREN>
  ) { return exp; }
}
