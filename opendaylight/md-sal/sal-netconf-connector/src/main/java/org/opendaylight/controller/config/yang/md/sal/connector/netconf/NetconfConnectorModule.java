/**
* Generated file

* Generated from: yang module name: opendaylight-sal-netconf-connector  yang module local name: sal-netconf-connector
* Generated by: org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator
* Generated at: Mon Nov 18 09:44:16 CET 2013
*
* Do not modify this file unless it is present under src/main directory
*/
package org.opendaylight.controller.config.yang.md.sal.connector.netconf;

import io.netty.channel.EventLoopGroup;
import io.netty.util.concurrent.GlobalEventExecutor;

import java.net.InetAddress;
import java.net.InetSocketAddress;

import javax.net.ssl.SSLContext;

import org.opendaylight.controller.netconf.client.NetconfClientDispatcher;
import org.opendaylight.controller.netconf.client.NetconfSshClientDispatcher;
import org.opendaylight.controller.netconf.util.handler.ssh.authentication.AuthenticationHandler;
import org.opendaylight.controller.netconf.util.handler.ssh.authentication.LoginPassword;
import org.opendaylight.controller.sal.connect.netconf.NetconfDevice;
import org.opendaylight.protocol.framework.ReconnectStrategy;
import org.opendaylight.protocol.framework.TimedReconnectStrategy;
import org.osgi.framework.BundleContext;

import static com.google.common.base.Preconditions.*;

import com.google.common.base.Optional;
import com.google.common.net.InetAddresses;

/**
*
*/
public final class NetconfConnectorModule extends org.opendaylight.controller.config.yang.md.sal.connector.netconf.AbstractNetconfConnectorModule
{

    private BundleContext bundleContext;

    public NetconfConnectorModule(org.opendaylight.controller.config.api.ModuleIdentifier identifier, org.opendaylight.controller.config.api.DependencyResolver dependencyResolver) {
        super(identifier, dependencyResolver);
    }

    public NetconfConnectorModule(org.opendaylight.controller.config.api.ModuleIdentifier identifier, org.opendaylight.controller.config.api.DependencyResolver dependencyResolver, NetconfConnectorModule oldModule, java.lang.AutoCloseable oldInstance) {
        super(identifier, dependencyResolver, oldModule, oldInstance);
    }

    @Override
    public void validate(){
        super.validate();
        checkState(getAddress() != null,"Address must be set.");
        //checkState(getAddress().getIpv4Address() != null || getAddress().getIpv6Address() != null,"Address must be set.");
        checkState(getPort() != null,"Port must be set.");
        checkState(getDomRegistry() != null,"Dom Registry must be provided.");
    }


    @Override
    public java.lang.AutoCloseable createInstance() {
        
        getDomRegistryDependency();
        NetconfDevice device = new NetconfDevice(getIdentifier().getInstanceName());
        String addressValue = getAddress();
        
        
        int attemptMsTimeout = 60*1000;
        int connectionAttempts = 5;
        /*
         * Uncomment after Switch to IP Address
        if(getAddress().getIpv4Address() != null) {
            addressValue = getAddress().getIpv4Address().getValue();
        } else {
            addressValue = getAddress().getIpv6Address().getValue();
        }
        
        */
        ReconnectStrategy strategy = new TimedReconnectStrategy(GlobalEventExecutor.INSTANCE, attemptMsTimeout, 1000, 1.0, null,
                Long.valueOf(connectionAttempts), null);
        
        
        device.setStrategy(strategy);
        
        InetAddress addr = InetAddresses.forString(addressValue);
        InetSocketAddress socketAddress = new InetSocketAddress(addr , getPort().intValue());
        device.setSocketAddress(socketAddress);
        
        EventLoopGroup bossGroup = getBossThreadGroupDependency();
        EventLoopGroup workerGroup = getWorkerThreadGroupDependency();
        NetconfClientDispatcher dispatcher = null;
        if(getTcpOnly()) {
            dispatcher = new NetconfClientDispatcher( bossGroup, workerGroup);
        } else {
            AuthenticationHandler authHandler = new LoginPassword(getUsername(),getPassword());
            dispatcher = new NetconfSshClientDispatcher(authHandler , bossGroup, workerGroup);
        }
        getDomRegistryDependency().registerProvider(device, bundleContext);
        
        device.start(dispatcher);
        return device;
    }

    public void setBundleContext(BundleContext bundleContext) {
        this.bundleContext = bundleContext;
    }
}
