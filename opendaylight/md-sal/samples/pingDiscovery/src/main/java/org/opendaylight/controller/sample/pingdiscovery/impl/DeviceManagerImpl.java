/*
* Copyright (c) 2014 Brocade Communications Systems, Inc. and others.  All rights reserved.
*
* This program and the accompanying materials are made available under the
* terms of the Eclipse Public License v1.0 which accompanies this distribution,
* and is available at http://www.eclipse.org/legal/epl-v10.html
*/
package org.opendaylight.controller.sample.pingdiscovery.impl;

import java.util.Collections;
import java.util.concurrent.Future;

import org.opendaylight.controller.md.sal.common.api.TransactionStatus;
import org.opendaylight.controller.sal.binding.api.data.DataModificationTransaction;
import org.opendaylight.controller.sal.binding.api.data.DataProviderService;
import org.opendaylight.controller.sample.pingdiscovery.DeviceManager;
import org.opendaylight.controller.sample.pingdiscovery.DeviceMountHandler;
import org.opendaylight.yang.gen.v1.http.opendaylight.org.samples.device.ip.rev140515.Node1;
import org.opendaylight.yang.gen.v1.http.opendaylight.org.samples.device.ip.rev140515.Node1Builder;
import org.opendaylight.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.inet.types.rev100924.IpAddress;
import org.opendaylight.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.inet.types.rev100924.IpAddressBuilder;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.NodeId;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.Nodes;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.NodesBuilder;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.nodes.Node;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.nodes.NodeBuilder;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.nodes.NodeKey;
import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.binding.InstanceIdentifier;
import org.opendaylight.yangtools.yang.common.RpcResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Responsible for creating Opendaylight-Inventory nodes in our data store, including setting our
 * augmented value.
 *
 * <br><br>DEMONSTRATES: How to create a node, with augmented data, to the operational data store.
 * @author Devin Avery
 * @author Greg Hall
 *
 */
public class DeviceManagerImpl implements DeviceManager {


    private final static InstanceIdentifier<Nodes> ROOT_NODES_PATH =
                                                InstanceIdentifier.builder(Nodes.class).build();
    private final Logger log = LoggerFactory.getLogger( DeviceManagerImpl.class );
    private DataProviderService dataBrokerService;
    private DeviceMountHandler rpcProvider;

    public void setDataBrokerService(DataProviderService dataBrokerService) {
        this.dataBrokerService = dataBrokerService;
    }

    public void setRpcProvider(DeviceMountHandler rpcProvider) {
        this.rpcProvider = rpcProvider;
    }

    @Override
    public boolean createDevice( final String ipAddrStr) {

        boolean retval = false ;

        String nodeIdStr = "ping_" + ipAddrStr;

        if( writeOperationalData(ipAddrStr, nodeIdStr) )
        {
            retval = true;
        }

        return retval ;
    }

    private boolean writeOperationalData(final String ipAddrStr,
            String nodeIdStr) {

      //we are checking if the item already exists. We don't want to create the node again, or
        //more importantly we don't want to try and mount our nodes a second time...(causes exceptions)
        DataObject dObj = dataBrokerService.readConfigurationData(createPath(nodeIdStr));
        if (dObj == null) {
            //builds up the Opendaylight-Inventory:Nodes:Node identifier using those autogenerated classes
            NodeId nodeId = new NodeId( nodeIdStr );
            NodeKey nodeKey = new NodeKey(nodeId);
            //Building up our augmentation of the basic node, where we add an IP address.
            //See the icmp_addressible_device.yang file.
            IpAddress addr = IpAddressBuilder.getDefaultInstance( ipAddrStr );
            Node1 ipAddrNode = new Node1Builder().setIpaddress( addr ).build();
            Node node = new NodeBuilder()
                                    .setId(nodeId)
                                    .setKey(nodeKey)
                                    .addAugmentation( Node1.class, ipAddrNode )
                                    .build();

            Nodes nodes = new NodesBuilder().setNode(
                    Collections.singletonList(node)).build();

            DataModificationTransaction txn = dataBrokerService.beginTransaction();
            //Here we are putting a basic shell of a node in both data stores. In reality you will
            //want to only put config data in the config path, and operational data in the operational
            //path.
            txn.putConfigurationData(ROOT_NODES_PATH, nodes);
            txn.putOperationalData(ROOT_NODES_PATH, nodes);

            try {
                Future<RpcResult<TransactionStatus>> commit = txn.commit();
                RpcResult<TransactionStatus> rpcResult = commit.get();
                TransactionStatus result = rpcResult.getResult();

                if( result.equals( TransactionStatus.FAILED ) ){
                    return false;
                }

                //calls into the logic to mount our additional data node.
                //Note: there is a race condition here - a second discovery may try and create the
                //same node. If that happens, the transaction would.... likely just merge the
                //update, which is fine in our simple example. Likely though our second attempt
                //to mount our yang model would throw an exception, which we should really do a better
                //job of handling..
                rpcProvider.mountIcmpDataNode( nodeIdStr );
            } catch (Exception e) {
                if( log.isErrorEnabled() )
                {
                    log.error( "Caught exception while trying to commit "
                            + "update to IP Device discovery.", e );
                }
                return false;
            }
        }

        return true;
    }

    private InstanceIdentifier<Node> createPath(String nodeIdStr) {
        return InstanceIdentifier.<Nodes>builder(Nodes.class)
                .<Node, NodeKey>child(Node.class, new NodeKey(new NodeId( nodeIdStr ))).toInstance();
    }

}
