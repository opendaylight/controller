module opendaylight-match-types {
    namespace "urn:opendaylight:model:match:types";
    prefix "match";

    import ietf-inet-types {prefix inet; revision-date "2010-09-24";}
    import ietf-yang-types {prefix yang; revision-date "2010-09-24";}
    import opendaylight-l2-types {prefix l2t;revision-date "2013-08-27";}
    import opendaylight-inventory {prefix inv;revision-date "2013-08-19";}

    revision "2013-10-26" {
        description "Initial revision of match types";
    }

    grouping "mac-address-filter" {
        leaf address {
            mandatory true;
            type yang:mac-address;
        }
        leaf mask {
            type yang:mac-address;
        }
    }

    grouping "of-metadata" {
        leaf metadata {
            type uint64;
        }

        leaf metadata-mask {
            type uint64;
        }
    }

    grouping ethernet-source-attributes{
        description "Ethernet source address.";
        uses mac-address-filter;
    }
    
    grouping ethernet-destination-attributes {
        description "Ethernet destination address.";
        uses mac-address-filter;
    }
    
    grouping ethernet-type-attributes {
        description "Ethernet frame type.";

        leaf type {
            mandatory true;
            type l2t:ether-type; // Needs to define that as general model
        }
    }
    
    // TODO - not sure what to do about vlan-id present
    grouping "vlan-match-fields" {
        container vlan-id {
            description "VLAN id.";
            presence "Match field is active and set";

            leaf vlan-id-present {
                type boolean;
            }

            leaf vlan-id {
                type l2t:vlan-id;
            }
        }
        leaf vlan-pcp {
            description "VLAN priority.";
            type l2t:vlan-pcp;
        }
    }

    grouping ip-protocol-attributes {
        leaf ip-protocol {
            description "IP protocol.";
            type uint8;
        }   
    }
    
    grouping ip-dscp-attributes {
        leaf ip-dscp {
            description "IP DSCP (6 bits in ToS field).";
            type inet:dscp;
        }
    }
    
    grouping ip-ecn-attributes {
        leaf ip-ecn {
            description "IP ECN (2 bits in ToS field).";
            type uint8;
        }
    }
    
    grouping ip-version-attributes {
        leaf ip-version {
            description "IP Proto (IPv4 or IPv6 Protocol Number).";
            type inet:ip-version;
         }
    }
    
    grouping ipv4-source {
        leaf ipv4-source {
            description "IPv4 source address.";
            type inet:ipv4-prefix;
        }
    }
    
    grouping ipv4-destination {
        leaf ipv4-destination {
            description "IPv4 destination address.";
            type inet:ipv4-prefix;
        }
    }

    grouping "ipv4-match-fields" {
        uses ipv4-source;
        uses ipv4-destination;
    }

    grouping ipv6-source {
        leaf ipv6-source {
            description "IPv6 source address.";
            type inet:ipv6-prefix;
        }
    }
    
    grouping ipv6-destination {
        leaf ipv6-destination {
            description "IPv6 destination address.";
            type inet:ipv6-prefix;
        }
    }
    
    grouping ipv6-nd-target {
        leaf ipv6-nd-target {
            description "IPv6 target address for neighbour discovery message";
            type inet:ipv6-address;
        }
    }
    
    grouping ipv6-label {
        leaf ipv6-flabel {
            type inet:ipv6-flow-label;
        }
        // TODO is this a good name for this?
        leaf flabel-mask {
            type inet:ipv6-flow-label;
        }
    }
    
    grouping ipv6-nd-sll {
        leaf ipv6-nd-sll {
            description "Link layer source address for neighbour discovery message";
            type yang:mac-address;
        }
    }
    
    grouping ipv6-nd-tll {
        leaf ipv6-nd-tll {
            description "Link layer target address for neighbour discovery message";
            type yang:mac-address;
        }
    }
    
    grouping ipv6-ext-header {
        container "ipv6-ext-header" {
            leaf ipv6-exthdr {
                description "IPv6 Extension Header field";
                type uint16;
            }

            leaf ipv6-exthdr-mask {
                type uint16 {
                  range "0..512";
                }
            }
        }
    }
    grouping "ipv6-match-fields" {
        uses ipv6-source;

        uses ipv6-destination;

        uses ipv6-nd-target;

        uses ipv6-label;

        uses ipv6-nd-sll;

        uses ipv6-nd-tll;

        uses ipv6-ext-header;
    }

    grouping udp-source-port {
        leaf udp-source-port {
            description "UDP source port.";
            type inet:port-number;
        }
    }
    
    grouping udp-destination-port {
        leaf udp-destination-port {
            description "UDP destination port.";
                type inet:port-number;
        }
    }
    
    
    grouping "udp-match-fields" {
        uses udp-source-port;
        uses udp-destination-port;
    }

    grouping mpls-label {
        leaf mpls-label {
            description "Label in the first MPLS shim header";
            type uint32;
        }
    }
    
    grouping mpls-tc {
        leaf mpls-tc {
            description "TC in the first MPLS shim header";
            type uint8;
        }
    }
    grouping mpls-bos {
        leaf mpls-bos {
            description "BoS bit in the first MPLS shim header";
            type uint8;
        }
    }
    
    grouping pbb {
        container "pbb" {
            leaf pbb-isid {
                description "I-SID in the first PBB service instance tag";
                type uint32;
            }

            leaf pbb-mask {
                type uint32 {
                  range "0..16777216";
                }
            }
        }
    }
    
    grouping "protocol-match-fields" {
        uses mpls-label;

        uses mpls-tc;

        uses mpls-bos;

        uses pbb;
    }

    grouping tcp-source-port {
        leaf tcp-source-port {
            description "TCP source port.";
            type inet:port-number;
        }
    }
    
    grouping tcp-destination-port {
        leaf tcp-destination-port {
            description "TCP destination port.";
            type inet:port-number;
        }
    }
    
    grouping tcp-match-fields {
        uses tcp-source-port;
        uses tcp-destination-port;
    }

    grouping sctp-source-port {
        leaf sctp-source-port {
            description "SCTP source port.";
            type inet:port-number;
        }
    }
    
    grouping sctp-destination-port {
        leaf sctp-destination-port {
            description "SCTP destination port.";
            type inet:port-number;
        }
    }
    
    grouping "sctp-match-fields" {
        uses sctp-source-port;
        uses sctp-destination-port;
    }
    
    grouping icmpv4-type {
        leaf icmpv4-type {
            description "ICMP type.";
            type uint8; // Define ICMP Type
        }
    }
    
    grouping icmpv4-code {
        leaf icmpv4-code {
            description "ICMP code.";
            type uint8; // Define ICMP Code
        }
    }

    grouping "icmpv4-match-fields" {
        uses icmpv4-type;
        uses icmpv4-code;
    }
    
    grouping icmpv6-type {
        leaf icmpv6-type {
            description "ICMP type.";
            type uint8; // Define ICMP Type
        }
    }
    
    grouping icmpv6-code {
        leaf icmpv6-code {
            description "ICMP code.";
            type uint8; // Define ICMP Code
        }
    }

    grouping "icmpv6-match-fields" {
        uses icmpv6-type;
        
        uses icmpv6-code;
    }
    
    grouping arp-op {
        leaf arp-op {
            type uint16; // TODO make semantic
        }
    }

    grouping arp-source-transport-address {
        leaf arp-source-transport-address {
            description "ARP source IPv4 address.";
            type inet:ipv4-prefix;
        }
    }
    
    grouping arp-target-transport-address {
        leaf arp-target-transport-address {
            description "ARP target IPv4 address.";
            type inet:ipv4-prefix;
        }
    }
    
    grouping arp-source-hardware-address {
        container arp-source-hardware-address {
            description "ARP source hardware address.";
            presence "Match field is active and set";
            uses mac-address-filter;
        }
    }
    
    grouping arp-target-hardware-address {
        container arp-target-hardware-address {
            description "ARP target hardware address.";
            presence "Match field is active and set";
            uses mac-address-filter;
        }
    }
    
    grouping "arp-match-fields" {
        uses arp-op;

        uses arp-source-transport-address;

        uses arp-target-transport-address;
        
        uses arp-source-hardware-address;
        
        uses arp-target-hardware-address;
    }

    grouping tcp-flag {
        leaf tcp-flag {
            type uint16;  // TODO For the love of God can we make this semantic
        }
    }
    
    grouping "tcp-flag-match-fields" {
        uses tcp-flag;
    }

    grouping tunnel-ipv4-source {
        leaf tunnel-ipv4-source {
            description "IPv4 source tunnel endpoint address.";
            type inet:ipv4-prefix;
        }
    }
    
    grouping tunnel-ipv4-destination {
        leaf tunnel-ipv4-destination {
            description "IPv4 destination tunnel endpoint address.";
            type inet:ipv4-prefix;
        }
    }
    
    grouping "tunnel-ipv4-match-fields" {
        uses tunnel-ipv4-source;
        uses tunnel-ipv4-destination;
    }
    
    grouping in-port {
        leaf in-port {
            type inv:node-connector-id;
        }
    }
    
    grouping in-phys-port {
        leaf in-phys-port {
            type inv:node-connector-id;
        }
    }
    
    grouping tunnel-id {
        container "tunnel" {
            leaf tunnel-id {
                description "Metadata associated in the logical port";
                type uint64;
            }

            leaf tunnel-mask {
                type uint64;
            }
        }
    }

    grouping match-list {
        list match {
            key "order";
            leaf order {
                type int32;
            }
            uses match-attributes;
        }
    }
    
    grouping match-attributes {
        choice match {
            case in-port-case {
                container in-port {
                    uses in-port;
                }
            }
            case in-phys-port-case {
                container in-phys-port {
                    uses in-phys-port;
                }
            }
            case metadata-case {
                container "metadata" {
                    uses of-metadata;
                }
            }
            
            case tunnel-case {
                uses tunnel-id;
            }
            
            case ethernet-source-case {
                container ethernet-source {
                    uses ethernet-source-attributes;
                }
            }
            
            case ethernet-destination-case {
                container ethernet-destination {
                    uses ethernet-destination-attributes;
                }
            }
            
            case ethernet-type-case {
                container ethernet-type {
                    uses ethernet-type-attributes;
                }
            }
            
            
            case vlan-match-case  {
                container "vlan-match" {
                    uses "vlan-match-fields";
                }
            }
            
            case ip-protocol-case {
                container ip-protocol {
                    uses ip-protocol-attributes;
                }
            }
            
            case ip-dscp-case {
                container ip-dscp {
                    uses ip-dscp-attributes;
                }
            }
            
            case ip-ecn-case {
                container ip-ecn {
                    uses ip-ecn-attributes;
                }
            }
            
            case ip-version-case {
                container ip-version {
                    uses ip-version-attributes;
                }
            }
            
            case layer-3-match-case {
                choice layer-3-match {
                    case "ipv4-match" {
                        uses "ipv4-match-fields";
                    }
                    case "ipv6-match" {
                        uses "ipv6-match-fields";
                    }
                    case "arp-match" {
                        uses "arp-match-fields";
                    }
                    case "tunnel-ipv4-match" {
                        uses "tunnel-ipv4-match-fields";
                    }
                }
            }
            case layer-4-match-case {
                choice layer-4-match {
                    case "udp-match" {
                        uses "udp-match-fields";
                    }
                    case "tcp-match" {
                        uses "tcp-match-fields";
                    }
                    case "sctp-match" {
                        uses "sctp-match-fields";
                    }
                }
            }
            case icmpv4-match {
                container "icmpv4-match" {
                    uses "icmpv4-match-fields";
                }
            }
            case icmpv6-match-case {
                
            }
            case protocol-match-fields-case {
                container "protocol-match-fields" {
                    uses "protocol-match-fields";
                }
            }
            
            case tcp-flag-match-case {
                container tcp-flag-match {
                    uses "tcp-flag-match-fields";
                }
            }
        }
    }
}