/**
 * Copyright (c) 2014 Cisco Systems, Inc. and others.  All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this distribution,
 * and is available at http://www.eclipse.org/legal/epl-v10.html
 */

package org.opendaylight.controller.frm;

import java.math.BigInteger;

import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.tables.Table;
import org.opendaylight.yangtools.yang.binding.InstanceIdentifier;

import com.google.common.base.Preconditions;
import com.google.common.util.concurrent.AtomicLongMap;

/**
 * forwardingrules-manager
 * org.opendaylight.controller.frm
 *
 * Singleton FlowCookieProducer contains a FlowCookie generator which is generated unique
 * flowCookie identifier for every flow in same Table. That could help with quick
 * identification of flow statistic because DataStore/CONFIGURATION could contains
 * a lot of flows with same flowCookie. So we are replacing original flowCookie
 * with unique and we are building final FlowCookieMap in DataStore/OPERATIONAL
 *
 * @author <a href="mailto:vdemcak@cisco.com">Vaclav Demcak</a>
 *
 * Created: Jun 13, 2014
 */
public enum FlowCookieProducer {

    INSTANCE;

    /* Flow_Cookie_Key and Flow_Ids MapHolder */
    private static final AtomicLongMap<InstanceIdentifier<Table>> cookieKeys = AtomicLongMap.create();

    /**
     * Method returns the unique cookie for a node table.
     * Flow Cookie Key signs List<FlowId> for a right flow statistic identification
     * in the DataStore/operational.
     * We need a List<FlowId> because system doesn't guarantee unique mapping
     * from flow_cookie to flow_id. REST Operations doesn't used FRM yet, so
     * cookie from user input could have a user input flow ID and an alien system ID
     * which is generated by system.
     *
     * @param InstanceIdentifier<Table> tableIdentifier
     * @return unique BigInteger flowCookie for a node table
     */
    public BigInteger getNewCookie(final InstanceIdentifier<Table> tableIdentifier) {
        FlowCookieProducer.validationTableIdentifier(tableIdentifier);
        if ( cookieKeys.containsKey(tableIdentifier)) {
            /* new identifier always starts from ONE because
             * ZERO is reserved for the NO_COOKIES flows */
            return BigInteger.valueOf(cookieKeys.addAndGet(tableIdentifier, 1L));
        } else {
            return BigInteger.valueOf(cookieKeys.incrementAndGet(tableIdentifier));
        }
    }

    /**
     * Method cleans the node table flow_cookie_key for the disconnected Node.
     *
     * @param InstanceIdentifier<Table> tableIdentifier
     */
    public void clean(final InstanceIdentifier<Table> tableIdentifier) {
        FlowCookieProducer.validationTableIdentifier(tableIdentifier);
        cookieKeys.remove(tableIdentifier);
    }

    /*
     * Help the TableIdentifer input validation method
     */
    private static void validationTableIdentifier(final InstanceIdentifier<Table> tableIdent) {
        Preconditions.checkArgument(tableIdent != null, "Input validation exception: TableIdentifier can not be null !");
    }
}
