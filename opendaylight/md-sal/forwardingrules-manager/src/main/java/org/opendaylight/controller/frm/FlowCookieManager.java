/**
 * Copyright (c) 2014 Cisco Systems, Inc. and others.  All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this distribution,
 * and is available at http://www.eclipse.org/legal/epl-v10.html
 */

package org.opendaylight.controller.frm;

import java.math.BigInteger;
import java.util.ArrayList;

import org.opendaylight.controller.sal.binding.api.data.DataModificationTransaction;
import org.opendaylight.controller.sal.binding.api.data.DataProviderService;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.FlowCookieMapping;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.FlowId;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.nodes.node.table.FlowCookieMap;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.nodes.node.table.FlowCookieMapBuilder;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.nodes.node.table.FlowCookieMapKey;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.tables.Table;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.types.rev131026.FlowCookie;
import org.opendaylight.yangtools.yang.binding.InstanceIdentifier;

import com.google.common.util.concurrent.AtomicLongMap;

/**
 * forwardingrules-manager
 * org.opendaylight.controller.frm
 *
 * Singleton FlowCookieManager contains a cookie identifier map
 * and the static help methods for update/add and remove
 * a twins cookie_key and List<FlowId> flowIds.
 *
 * @author <a href="mailto:vdemcak@cisco.com">Vaclav Demcak</a>
 *
 * Created: Jun 13, 2014
 */
public enum FlowCookieManager {

    INSTANCE;

    /* Flow_Cookie_Key and Flow_Ids MapHolder */
    private static final AtomicLongMap<InstanceIdentifier<Table>> cookieKeys = AtomicLongMap.create();

    /**
     * Method returns the unique cookie for a node table.
     * Flow Cookie Key signs List<FlowId> for a right flow statistic identification
     * in the Operational DataStore.
     * We need a List<FlowId> because system doesn't guarantee unique mapping
     * from flow_cookie to flow_id. REST Operations doesn't used FRM yet, so
     * cookie from user input could have a user input flow ID and an alien system ID
     * which is generated by system.
     *
     * @param InstanceIdentifier<Table> tableIdentifier
     * @return unique BigInteger flowCookie for a node table
     */
    public BigInteger getNewCookie(final InstanceIdentifier<Table> tableIdentifier) {
        FlowCookieManager.validationTableIdentifier(tableIdentifier);
        if ( cookieKeys.containsKey(tableIdentifier)) {
            /* new identifier always starts from ONE because
             * ZERO is reserved for the NO_COOKIES flows */
            return BigInteger.valueOf(cookieKeys.addAndGet(tableIdentifier, 1L));
        } else {
            return BigInteger.valueOf(cookieKeys.incrementAndGet(tableIdentifier));
        }
    }

    /**
     * Method cleans the node table flow_cookie_key for the disconnected Node.
     *
     * @param InstanceIdentifier<Table> tableIdentifier
     */
    public void clean(final InstanceIdentifier<Table> tableIdentifier) {
        FlowCookieManager.validationTableIdentifier(tableIdentifier);
        cookieKeys.remove(tableIdentifier);
    }

    /**
     * Method removes the FlowId identified by the flow_cookie from
     * the Operational DataStore.
     *
     * @param dataService
     * @param flowCookie
     * @param flowId
     * @param tableIdentifier
     */
    public static void flowCookieMapRemove (final DataProviderService dataService,
                                            final FlowCookie flowCookie,
                                            final FlowId flowId,
                                            final InstanceIdentifier<Table> tableIdentifier) {

        validationInputValues(dataService, flowCookie, flowId, tableIdentifier);

        InstanceIdentifier<FlowCookieMap> flowCookieRef = tableIdentifier
                .augmentation(FlowCookieMapping.class)
                .child(FlowCookieMap.class, new FlowCookieMapKey(flowCookie));

        DataModificationTransaction modif = dataService.beginTransaction();
        FlowCookieMap operFlowCookieMap = (FlowCookieMap) modif.readOperationalData(flowCookieRef);
        if (operFlowCookieMap.getFlowIds().size() == 1) {
            modif.removeOperationalData(flowCookieRef);
        } else {
            operFlowCookieMap.getFlowIds().remove(flowId);
            modif.putOperationalData(flowCookieRef, operFlowCookieMap);
        }

        modif.commit();
    }

    /**
     * Method puts the FlowId identified by the flow_cookie to
     * the Operational DataStore.
     *
     * @param DataProviderService dataService
     * @param FlowCookie flowCookie
     * @param FlowId flowId
     * @param InstanceIdentifier<Table> tableRef
     */
    public static void flowCookieMapUpdate (final DataProviderService dataService,
                                            final FlowCookie flowCookie,
                                            final FlowId flowId,
                                            final InstanceIdentifier<Table> tableIdentifier) {

        validationInputValues(dataService, flowCookie, flowId, tableIdentifier);

        InstanceIdentifier<FlowCookieMap> flowCookieRef = tableIdentifier
                .augmentation(FlowCookieMapping.class)
                .child(FlowCookieMap.class, new FlowCookieMapKey(flowCookie));

        DataModificationTransaction modif = dataService.beginTransaction();
        FlowCookieMap operCookie = (FlowCookieMap) modif.readOperationalData(flowCookieRef);

        if (operCookie == null) {
            final FlowCookieMapBuilder flowCookieMapBuilder = new FlowCookieMapBuilder();
            flowCookieMapBuilder.setCookie(flowCookie);
            flowCookieMapBuilder.setFlowIds(new ArrayList<FlowId>(){{ this.add(flowId); }});
            operCookie = flowCookieMapBuilder.build();
        } else {
            operCookie.getFlowIds().add(flowId);
        }

        modif.putOperationalData(flowCookieRef, operCookie);
        modif.commit();
    }

    /*
     * Help the input validation method
     */
    private static void validationInputValues(final DataProviderService dataService,
                                              final FlowCookie flowCookie,
                                              final FlowId flowId,
                                              final InstanceIdentifier<Table> tableIdentifier) {
        if (dataService == null) {
            throw new IllegalArgumentException("DataProviderService can not be null !");
        }
        if (flowCookie == null) {
            throw new IllegalArgumentException("FlowCookie can not be null !");
        }
        if (flowId == null) {
            throw new IllegalArgumentException("FlowId can not be null !");
        }
        validationTableIdentifier(tableIdentifier);
    }

    /*
     * Help the TableIdentifer input validation method
     */
    private static void validationTableIdentifier(final InstanceIdentifier<Table> tableIdentifier) {
        if (tableIdentifier == null) {
            throw new IllegalArgumentException("TableIdentifier can not be null !");
        }
    }
}
