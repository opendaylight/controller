/**
 * Copyright (c) 2014 Cisco Systems, Inc. and others.  All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this distribution,
 * and is available at http://www.eclipse.org/legal/epl-v10.html
 */

package org.opendaylight.controller.frm;

import java.math.BigInteger;
import java.util.ArrayList;

import org.opendaylight.controller.sal.binding.api.data.DataModificationTransaction;
import org.opendaylight.controller.sal.binding.api.data.DataProviderService;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.FlowCookieMapping;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.FlowId;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.nodes.node.table.FlowCookieMap;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.nodes.node.table.FlowCookieMapBuilder;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.nodes.node.table.FlowCookieMapKey;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.tables.Table;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.types.rev131026.FlowCookie;
import org.opendaylight.yangtools.yang.binding.InstanceIdentifier;

import com.google.common.util.concurrent.AtomicLongMap;

/**
 * forwardingrules-manager
 * org.opendaylight.controller.frm
 *
 * Singleton FlowCookieManager contains a cookie identifier map
 * and the static help methods for update/add and remove
 * a twins cookie_key and List<FlowId> flowIds.
 *
 * @author <a href="mailto:vdemcak@cisco.com">Vaclav Demcak</a>
 *
 * Created: Jun 13, 2014
 */
public enum FlowCookieManager {

    INSTANCE;

    /* Flow_Cookie_Key and Flow_Ids MapHolder */
    private static final AtomicLongMap<InstanceIdentifier<Table>> cookieKeys = AtomicLongMap.create();

    /**
     * Method returns the unique cookie for a node table.
     * Flow Cookie Key signs List<FlowId> for a right flow statistic identification
     * in the Operational DataStore.
     * We need a List<FlowId> because system doesn't guarantee unique mapping
     * from flow_cookie to flow_id. REST Operations doesn't used FRM yet, so
     * cookie from user input could have a user input flow ID and an alien system ID
     * which is generated by system.
     *
     * @param InstanceIdentifier<Table> tableIdentifier
     * @return unique BigInteger flowCookie for a node table
     */
    public BigInteger getNewCookie(final InstanceIdentifier<Table> tableIdentifier) {
        if ( cookieKeys.containsKey( tableIdentifier ) ) {
            /* new identifier always starts from ONE because
             * ZERO is reserved for the NO_COOKIES flows */
            return BigInteger.valueOf( cookieKeys.addAndGet( tableIdentifier, 1L ) );
        } else {
            return BigInteger.valueOf( cookieKeys.incrementAndGet( tableIdentifier ) );
        }
    }

    /**
     * Method cleans the node table flow_cookie_key for the disconnected Node.
     *
     * @param InstanceIdentifier<Table> tableIdentifier
     */
    public void clean(final InstanceIdentifier<Table> tableIdentifier) {
        cookieKeys.remove( tableIdentifier );
    }

    /**
     * Method removes the FlowId identified by the flow_cookie from
     * the Operational DataStore.
     *
     * @param dataService
     * @param flowCookie
     * @param flowId
     * @param tableIdentifier
     */
    public static void flowCookieMapRemove ( final DataProviderService dataService,
                                             final FlowCookie flowCookie,
                                             final FlowId flowId,
                                             final InstanceIdentifier<Table> tableIdentifier ) {

        InstanceIdentifier<FlowCookieMap> flowCookieRef = tableIdentifier.builder()
                .augmentation( FlowCookieMapping.class )
                .child( FlowCookieMap.class, new FlowCookieMapKey( flowCookie ) ).build();

        DataModificationTransaction modif = dataService.beginTransaction();
        FlowCookieMap operFlowCookieMap = (FlowCookieMap) modif.readOperationalData( flowCookieRef );
        if ( operFlowCookieMap.getFlowIds().size() == 1 ) {
            modif.removeOperationalData( flowCookieRef );
        } else {
            operFlowCookieMap.getFlowIds().remove( flowId );
            modif.putOperationalData( flowCookieRef, operFlowCookieMap );
        }

        modif.commit();
    }

    /**
     * Method puts the FlowId identified by the flow_cookie to
     * the Operational DataStore.
     *
     * @param DataProviderService dataService
     * @param FlowCookie flowCookie
     * @param FlowId flowId
     * @param InstanceIdentifier<Table> tableRef
     */
    public static void flowCookieMapUpdate ( final DataProviderService dataService,
                                             final FlowCookie flowCookie,
                                             final FlowId flowId,
                                             final InstanceIdentifier<Table> tableIdentifier ) {

        InstanceIdentifier<FlowCookieMap> flowCookieRef = tableIdentifier.builder()
                .augmentation( FlowCookieMapping.class )
                .child( FlowCookieMap.class, new FlowCookieMapKey( flowCookie ) ).build();

        DataModificationTransaction modif = dataService.beginTransaction();
        FlowCookieMap operCookie = (FlowCookieMap) modif.readOperationalData( flowCookieRef );

        if (operCookie != null) {
            operCookie.getFlowIds().add( flowId );
        } else {
            final FlowCookieMapBuilder flowCookieMapBuilder = new FlowCookieMapBuilder();
            flowCookieMapBuilder.setCookie( flowCookie );
            flowCookieMapBuilder.setFlowIds( new ArrayList<FlowId>() {{ this.add( flowId ); }} );
            operCookie = flowCookieMapBuilder.build();
        }

        modif.putOperationalData( flowCookieRef, operCookie );
        modif.commit();
    }
}
