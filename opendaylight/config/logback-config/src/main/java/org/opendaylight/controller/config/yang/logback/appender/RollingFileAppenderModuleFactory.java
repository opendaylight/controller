/**
 * Generated file

 * Generated from: yang module name: config-logback-appender  yang module local name: rolling-file-appender
 * Generated by: org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator
 * Generated at: Thu Feb 06 17:13:23 CET 2014
 *
 * Do not modify this file unless it is present under src/main directory
 */
package org.opendaylight.controller.config.yang.logback.appender;

import ch.qos.logback.core.rolling.FixedWindowRollingPolicy;
import ch.qos.logback.core.rolling.RollingFileAppender;
import ch.qos.logback.core.rolling.RollingPolicy;
import ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy;
import ch.qos.logback.core.rolling.TimeBasedRollingPolicy;
import ch.qos.logback.core.rolling.TriggeringPolicy;
import com.google.common.base.Preconditions;
import com.google.common.collect.Sets;
import org.opendaylight.controller.config.api.DependencyResolverFactory;
import org.opendaylight.controller.config.api.ModuleIdentifier;
import org.opendaylight.controller.config.yang.logback.util.AppenderDiscovery;
import org.opendaylight.controller.config.yang.logback.util.AppenderFactoryUtil;
import org.osgi.framework.BundleContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class RollingFileAppenderModuleFactory extends org.opendaylight.controller.config.yang.logback.appender.AbstractRollingFileAppenderModuleFactory {
    private static final Logger logger = LoggerFactory.getLogger(RollingFileAppenderModuleFactory.class);

    public static final String INSTANCE_NAME = "singleton";

    //Enforce singleton
    @Override
    public RollingFileAppenderModule createModule(String instanceName, org.opendaylight.controller.config.api.DependencyResolver dependencyResolver, org.osgi.framework.BundleContext bundleContext) {
        Preconditions.checkArgument(INSTANCE_NAME.equals(instanceName), "Wrong instanceName, only allowed is " + INSTANCE_NAME);
        return (RollingFileAppenderModule) super.createModule(instanceName, dependencyResolver, bundleContext);
    }

    @Override
    public Set<RollingFileAppenderModule> getDefaultModules(DependencyResolverFactory dependencyResolverFactory, BundleContext bundleContext) {
        ModuleIdentifier moduleIdentifier = new ModuleIdentifier(NAME, INSTANCE_NAME);

        if (dependencyResolverFactory.createTemporaryDependencyResolver().containsDependency(moduleIdentifier)) {
            return Collections.emptySet();
        }

        RollingFileAppenderModule defaultModule = createModule(INSTANCE_NAME, dependencyResolverFactory.createDependencyResolver(
                moduleIdentifier), bundleContext);
        Map<String, RollingFileAppender> current = new AppenderDiscovery().findAppenders(RollingFileAppender.class);
        List<RollingFileAppenderTO> tos = new ArrayList<>(current.size());
        for (RollingFileAppender appender : current.values()) {
            if (AppenderFactoryUtil.isEncoderSupported(appender) == false) {
                logger.warn("Encoder/pattern in appender " + appender.getName() + " was not recognized:" +
                        appender.getEncoder() + " , skipping appender");
                continue;
            }
            RollingFileAppenderTO to = AppenderFactoryUtil.setName_EncoderPattern_ThresholdFilter(appender, new RollingFileAppenderTO());
            tos.add(to);
            // file
            to.setFile(appender.getFile());
            // read size based triggering policy
            TriggeringPolicy triggeringPolicy = appender.getTriggeringPolicy();
            if (triggeringPolicy instanceof SizeBasedTriggeringPolicy == false) {
                logger.warn("Triggering policy " + triggeringPolicy  +" is not supported, skipping " + appender.getName());
                continue;
            }
            SizeBasedTriggeringPolicy sizeBasedTriggeringPolicy = (SizeBasedTriggeringPolicy) triggeringPolicy;
            SizeBasedTriggeringPolicyTO triggeringTO = new SizeBasedTriggeringPolicyTO();
            triggeringTO.setMaxFileSize(sizeBasedTriggeringPolicy.getMaxFileSize());
            to.setSizeBasedTriggeringPolicy(triggeringTO);

            RollingPolicy rollingPolicy = appender.getRollingPolicy();
            if (rollingPolicy instanceof TimeBasedRollingPolicy) {
                TimeBasedRollingPolicy timeBasedRollingPolicy = (TimeBasedRollingPolicy) rollingPolicy;
                TimeBasedRollingPolicyTO rollingTO = new TimeBasedRollingPolicyTO();
                to.setTimeBasedRollingPolicy(rollingTO);
                rollingTO.setFileNamePattern(timeBasedRollingPolicy.getFileNamePattern());
                rollingTO.setMaxHistory(timeBasedRollingPolicy.getMaxHistory());
                rollingTO.setCleanHistoryOnStart(timeBasedRollingPolicy.isCleanHistoryOnStart());
            } else if (rollingPolicy instanceof FixedWindowRollingPolicy) {
                FixedWindowRollingPolicy fixedWindowRollingPolicy = (FixedWindowRollingPolicy) rollingPolicy;
                FixedWindowRollingPolicyTO rollingTO = new FixedWindowRollingPolicyTO();
                to.setFixedWindowRollingPolicy(rollingTO);
                rollingTO.setFileNamePattern(fixedWindowRollingPolicy.getFileNamePattern());
                rollingTO.setMinIndex(fixedWindowRollingPolicy.getMinIndex());
                rollingTO.setMaxIndex(fixedWindowRollingPolicy.getMaxIndex());
            } else {
                logger.warn("Rolling policy " + rollingPolicy + " is not supported, skipping " + appender.getName());
            }
        }
        defaultModule.setRollingFileAppenderTO(tos);
        return Sets.newHashSet(defaultModule);
    }
}
