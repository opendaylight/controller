/**
 * Generated file

 * Generated by: org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator
 * Generated at: Wed Jul 17 15:26:45 CEST 2013
 *
 * Do not modifiy this file unless it is present under src/main directory
 */
package org.opendaylight.controller.config.yang.logback.config;

import java.util.*;
import java.util.Map.Entry;

import org.apache.commons.lang3.StringUtils;
import org.opendaylight.controller.config.api.DependencyResolver;
import org.opendaylight.controller.config.api.ModuleIdentifier;
import org.slf4j.LoggerFactory;

import ch.qos.logback.classic.Logger;
import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.encoder.PatternLayoutEncoder;
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.classic.spi.LoggerComparator;
import ch.qos.logback.core.Appender;
import ch.qos.logback.core.rolling.FixedWindowRollingPolicy;
import ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy;

import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;

/**
*
*/
public class LogbackModuleFactory
        extends
        org.opendaylight.controller.config.yang.logback.config.AbstractLogbackModuleFactory {

    private static final String INSTANCE_NAME = "singleton";
    private Map<String, LoggerTO> loggersDTOs;
    private Map<String, RollingFileAppenderTO> rollingDTOs;
    private Map<String, ConsoleAppenderTO> consoleDTOs;

    @Override
    public LogbackModule instantiateModule(String instanceName,
            DependencyResolver dependencyResolver) {
        Preconditions.checkArgument(instanceName.equals(INSTANCE_NAME),
                "There should be just one instance of logback, named "
                        + INSTANCE_NAME);
        prepareDTOs();
        LogbackModule module = new LogbackModule(new ModuleIdentifier(
                getImplementationName(), INSTANCE_NAME), dependencyResolver);
        module.setConsoleAppenderTO(Lists.newArrayList(consoleDTOs.values()));
        module.setRollingFileAppenderTO(Lists.newArrayList(rollingDTOs.values()));
        module.setLoggerTO(Lists.newArrayList(loggersDTOs.values()));
        return module;
    }

    @Override
    public LogbackModule instantiateModule(String instanceName,
            DependencyResolver dependencyResolver, LogbackModule oldModule,
            AutoCloseable oldInstance) {
        Preconditions.checkArgument(instanceName.equals(INSTANCE_NAME),
                "There should be just one instance of logback, named "
                        + INSTANCE_NAME);
        prepareDTOs();
        LogbackModule module = new LogbackModule(new ModuleIdentifier(
                getImplementationName(), INSTANCE_NAME), dependencyResolver,
                oldModule, oldInstance);
        module.setConsoleAppenderTO(Lists.newArrayList(consoleDTOs.values()));
        /*
         * module.setJCloudsAppender(Lists.newArrayList(jcloudsDTOs.values()));
         */
        module.setRollingFileAppenderTO(Lists.newArrayList(rollingDTOs.values()));
        module.setLoggerTO(Lists.newArrayList(loggersDTOs.values()));
        return module;
    }

    private void prepareDTOs() {
        LoggerContext context = (LoggerContext) LoggerFactory
                .getILoggerFactory();
        this.loggersDTOs = prepareLoggersDTOs(context);
        prepareAppendersDTOs(context);
    }

    private void prepareAppendersDTOs(LoggerContext context) {
        this.rollingDTOs = new HashMap<>();
        this.consoleDTOs = new HashMap<>();
        ch.qos.logback.core.rolling.RollingFileAppender<ILoggingEvent> rollingApp;
        ch.qos.logback.core.ConsoleAppender<ILoggingEvent> consoleApp;
        Map<Logger, List<Appender<ILoggingEvent>>> appendersAll = new HashMap<>();
        for (Logger log : context.getLoggerList()) {
            List<Appender<ILoggingEvent>> appenders = new ArrayList<>();
            Iterator<Appender<ILoggingEvent>> iter = log.iteratorForAppenders();
            while (iter.hasNext()) {
                Appender<ILoggingEvent> element = iter.next();
                appenders.add(element);
            }
            appendersAll.put(log, appenders);
        }
        for (List<ch.qos.logback.core.Appender<ILoggingEvent>> appEntry : appendersAll.values()) {
            for (ch.qos.logback.core.Appender<ILoggingEvent> appender : appEntry) {
                if (appender instanceof ch.qos.logback.core.rolling.RollingFileAppender<?>) {
                    RollingFileAppenderTO app = new RollingFileAppenderTO();
                    rollingApp = (ch.qos.logback.core.rolling.RollingFileAppender< ILoggingEvent >) appender;
                    app.setAppend(rollingApp.isAppend());
                    PatternLayoutEncoder encoder = (PatternLayoutEncoder) rollingApp
                            .getEncoder();
                    app.setEncoderPattern(encoder.getPattern());
                    app.setFileName(rollingApp.getFile());
                    FixedWindowRollingPolicy rollingPolicy = (FixedWindowRollingPolicy) rollingApp
                            .getRollingPolicy();
                    app.setMaxIndex(rollingPolicy.getMaxIndex());
                    app.setMinIndex(rollingPolicy.getMinIndex());
                    SizeBasedTriggeringPolicy<ILoggingEvent> triggeringPolicy = (SizeBasedTriggeringPolicy<ILoggingEvent>) rollingApp
                            .getTriggeringPolicy();
                    app.setMaxFileSize(triggeringPolicy.getMaxFileSize());
                    app.setFileNamePattern(rollingPolicy.getFileNamePattern());
                    app.setName(rollingApp.getName());
                    this.rollingDTOs.put(rollingApp.getName(), app);
                }
                if (appender instanceof ch.qos.logback.core.ConsoleAppender<?>) {
                    ConsoleAppenderTO app = new ConsoleAppenderTO();
                    consoleApp = (ch.qos.logback.core.ConsoleAppender<ILoggingEvent>) appender;
                    consoleApp.getCopyOfAttachedFiltersList();
                    PatternLayoutEncoder encoder = (PatternLayoutEncoder) consoleApp
                            .getEncoder();
                    app.setEncoderPattern(encoder.getPattern());
                    app.setName(consoleApp.getName());
                    app.setThresholdFilter(context.getLogger(
                            Logger.ROOT_LOGGER_NAME).getEffectiveLevel().levelStr);
                    this.consoleDTOs.put(consoleApp.getName(), app);
                }
            }
        }
    }

    private Map<String, LoggerTO> prepareLoggersDTOs(
            LoggerContext context) {
        Map<String, LoggerTO> DTOs = new HashMap<>();
        List<String> appenders = new ArrayList<>();
        List<org.slf4j.Logger> loggersToBeAdd = removeUnusableLoggers(
                context.getLoggerList(),
                context.getLogger(Logger.ROOT_LOGGER_NAME));
        for (org.slf4j.Logger log : loggersToBeAdd) {
            LoggerTO logger = new LoggerTO();
            if (((Logger) log).getLevel() != null)
                logger.setLevel(((Logger) log).getLevel().levelStr);
            else
                logger.setLevel(((Logger) log).getEffectiveLevel().levelStr);
            logger.setLoggerName(log.getName());
            Iterator<Appender<ILoggingEvent>> iter = ((Logger) log)
                    .iteratorForAppenders();
            while (iter.hasNext()) {
                Appender<ILoggingEvent> element = iter.next();
                appenders.add(element.getName());
            }
            logger.setAppenders(appenders);
            DTOs.put(log.getName(), logger);
            appenders = new ArrayList<>();

        }
        return DTOs;
    }

    private List<org.slf4j.Logger> removeUnusableLoggers(
            List<Logger> loggerList, Logger rootLogger) {
        Collections.sort(loggerList, new LoggerComparator());
        Map<String, org.slf4j.Logger> loggersToReturn = new HashMap<>();

        for (org.slf4j.Logger log : loggerList) {
            boolean shouldAdd = true;
            for (Entry<String, org.slf4j.Logger> entry : loggersToReturn
                    .entrySet()) {
                if (StringUtils.contains(log.getName(), entry.getKey())) {
                    if (((Logger) log).getLevel() != null
                            && ((Logger) log).getLevel().equals(
                                    ((Logger) entry.getValue()).getLevel())
                            && !((Logger) log).iteratorForAppenders().hasNext()) {
                        shouldAdd = false;
                        break;
                    }
                    if (((Logger) log).getLevel() == null
                            && ((Logger) log).getEffectiveLevel().equals(
                                    ((Logger) entry.getValue())
                                            .getEffectiveLevel())
                            && !((Logger) log).iteratorForAppenders().hasNext()) {
                        shouldAdd = false;
                        break;
                    }
                }
                if (((Logger) log).getLevel() != null
                        && ((Logger) log).getLevel().equals(
                                rootLogger.getLevel())
                        && !((Logger) log).iteratorForAppenders().hasNext()) {
                    shouldAdd = false;
                    break;
                }
                if (((Logger) log).getLevel() == null
                        && ((Logger) log).getEffectiveLevel().equals(
                                rootLogger.getEffectiveLevel())
                        && !((Logger) log).iteratorForAppenders().hasNext()) {
                    shouldAdd = false;
                    break;
                }
            }
            if (shouldAdd) {
                loggersToReturn.put(log.getName(), log);
            }
        }
        return Lists.newArrayList(loggersToReturn.values());
    }

}
